"""
Input/output utilities for MIDI, MusicXML, LilyPond, ABC, and WAV export.
"""

from pathlib import Path
from typing import Union, Optional
import music21 as m21
from music21 import stream


def to_midi(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to MIDI format.

    Args:
        score: The Score to export
        path: Destination file path

    Returns:
        Path to the written MIDI file
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    mf = m21.midi.translate.music21ObjectToMidiFile(score)
    mf.open(str(path), 'wb')
    mf.write()
    mf.close()

    return path


def to_musicxml(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to MusicXML format.

    Args:
        score: The Score to export
        path: Destination file path

    Returns:
        Path to the written MusicXML file
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    score.write('musicxml', fp=str(path))

    return path


def to_lilypond(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to LilyPond format (.ly).

    LilyPond is a music engraving program that produces
    high-quality sheet music. The .ly file can be compiled
    with LilyPond to generate PDF or PNG output.

    Args:
        score: The Score to export
        path: Destination file path (should end with .ly)

    Returns:
        Path to the written LilyPond file

    Example:
        >>> to_lilypond(my_score, 'output.ly')
        >>> # Then compile with: lilypond output.ly
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    # Generate LilyPond content manually
    ly_content = _generate_lilypond_content(score)
    path.write_text(ly_content, encoding='utf-8')

    return path


def _generate_lilypond_content(score: stream.Score) -> str:
    """Generate LilyPond format content from a score."""
    from music21 import pitch as m21pitch

    parts_ly = []

    for i, part in enumerate(score.parts):
        notes_ly = []
        for element in part.flatten().notesAndRests:
            if element.isNote:
                # Convert pitch to LilyPond notation
                p = element.pitch
                note_name = p.step.lower()

                # Handle accidentals
                if p.accidental:
                    if p.accidental.name == 'sharp':
                        note_name += 'is'
                    elif p.accidental.name == 'flat':
                        note_name += 'es'

                # Handle octave (middle C = c')
                octave = p.octave - 3
                if octave > 0:
                    note_name += "'" * octave
                elif octave < 0:
                    note_name += "," * abs(octave)

                # Handle duration
                duration = int(4 / element.quarterLength) if element.quarterLength > 0 else 4
                notes_ly.append(f"{note_name}{duration}")
            elif element.isRest:
                duration = int(4 / element.quarterLength) if element.quarterLength > 0 else 4
                notes_ly.append(f"r{duration}")

        part_content = " ".join(notes_ly)
        parts_ly.append(f'  \\new Staff {{\n    {part_content}\n  }}')

    parts_section = '\n'.join(parts_ly)

    lily_template = f'''\\version "2.20.0"
\\header {{
  title = "Canon"
  composer = "Generated by Cancrizans"
}}

\\score {{
  <<
{parts_section}
  >>
  \\layout {{ }}
  \\midi {{ }}
}}
'''

    return lily_template


def to_abc(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to ABC notation format (.abc).

    ABC notation is a text-based music notation system
    that's compact and easy to read/edit. It's widely used
    for folk music and can be rendered by many programs.

    Args:
        score: The Score to export
        path: Destination file path (should end with .abc)

    Returns:
        Path to the written ABC file

    Example:
        >>> to_abc(my_score, 'output.abc')
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    # Generate ABC content manually
    abc_content = _generate_abc_content(score)
    path.write_text(abc_content, encoding='utf-8')

    return path


def _generate_abc_content(score: stream.Score) -> str:
    """Generate ABC notation format content from a score."""
    # ABC header
    abc_lines = [
        "X:1",
        "T:Canon",
        "C:Generated by Cancrizans",
        "M:4/4",
        "L:1/4",
        "K:C",
        ""
    ]

    # Convert each part
    for i, part in enumerate(score.parts):
        if i > 0:
            abc_lines.append(f"V:{i+1}")

        notes_abc = []
        for element in part.flatten().notesAndRests:
            if element.isNote:
                # Convert pitch to ABC notation
                p = element.pitch
                note_name = p.step

                # Handle accidentals
                if p.accidental:
                    if p.accidental.name == 'sharp':
                        note_name = '^' + note_name
                    elif p.accidental.name == 'flat':
                        note_name = '_' + note_name

                # Handle octave (middle C = C)
                if p.octave >= 5:
                    note_name = note_name.lower()
                    if p.octave > 5:
                        note_name += "'" * (p.octave - 5)
                elif p.octave < 4:
                    note_name += "," * (4 - p.octave)

                # Handle duration (ABC uses different notation)
                duration = ""
                if element.quarterLength == 0.5:
                    duration = "/2"
                elif element.quarterLength == 2.0:
                    duration = "2"
                elif element.quarterLength == 1.5:
                    duration = "3/2"
                elif element.quarterLength != 1.0:
                    # General case
                    duration = str(int(element.quarterLength)) if element.quarterLength.is_integer() else f"{int(element.quarterLength*2)}/2"

                notes_abc.append(note_name + duration)
            elif element.isRest:
                duration = ""
                if element.quarterLength == 0.5:
                    duration = "/2"
                elif element.quarterLength == 2.0:
                    duration = "2"
                elif element.quarterLength != 1.0:
                    duration = str(int(element.quarterLength)) if element.quarterLength.is_integer() else f"{int(element.quarterLength*2)}/2"
                notes_abc.append("z" + duration)

        abc_lines.append(" ".join(notes_abc))

    return "\n".join(abc_lines)


def to_wav_via_sf2(
    midi_path: Union[str, Path],
    sf2_path: Union[str, Path],
    wav_path: Union[str, Path]
) -> Optional[Path]:
    """
    Convert MIDI to WAV using a SoundFont file.

    This function requires either FluidSynth or the midi2audio library.
    If neither is available, it returns None and prints a message.

    Args:
        midi_path: Path to input MIDI file
        sf2_path: Path to SoundFont (.sf2) file
        wav_path: Path for output WAV file

    Returns:
        Path to the WAV file if successful, None otherwise
    """
    midi_path = Path(midi_path)
    sf2_path = Path(sf2_path)
    wav_path = Path(wav_path)

    if not midi_path.exists():
        raise FileNotFoundError(f"MIDI file not found: {midi_path}")

    if not sf2_path.exists():
        raise FileNotFoundError(f"SoundFont file not found: {sf2_path}")

    wav_path.parent.mkdir(parents=True, exist_ok=True)

    try:
        # Try using midi2audio if available
        from midi2audio import FluidSynth

        fs = FluidSynth(sound_font=str(sf2_path))
        fs.midi_to_audio(str(midi_path), str(wav_path))

        return wav_path

    except ImportError:
        print(
            "WAV export requires midi2audio and FluidSynth.\n"
            "Install with: pip install midi2audio\n"
            "And ensure FluidSynth is installed on your system:\n"
            "  Ubuntu/Debian: sudo apt-get install fluidsynth\n"
            "  macOS: brew install fluid-synth\n"
            "  Windows: Download from https://www.fluidsynth.org/"
        )
        return None
    except Exception as e:
        print(f"Error converting MIDI to WAV: {e}")
        return None


def load_score(path: Union[str, Path]) -> stream.Score:
    """
    Load a score from a MusicXML or MIDI file.

    Args:
        path: Path to the file to load

    Returns:
        The loaded Score object
    """
    path = Path(path)

    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")

    score = m21.converter.parse(str(path))

    # Ensure we have a Score object
    if isinstance(score, stream.Score):
        return score
    elif isinstance(score, stream.Part):
        # Wrap single part in a score
        s = stream.Score()
        s.insert(0, score)
        return s
    else:
        # Try to convert other types
        s = stream.Score()
        s.insert(0, score)
        return s
