"""
Input/output utilities for MIDI, MusicXML, LilyPond, ABC, and WAV export.
"""

from pathlib import Path
from typing import Union, Optional
import music21 as m21
from music21 import stream


def to_midi(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to MIDI format.

    Args:
        score: The Score to export
        path: Destination file path

    Returns:
        Path to the written MIDI file
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    mf = m21.midi.translate.music21ObjectToMidiFile(score)
    mf.open(str(path), 'wb')
    mf.write()
    mf.close()

    return path


def to_musicxml(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to MusicXML format.

    Args:
        score: The Score to export
        path: Destination file path

    Returns:
        Path to the written MusicXML file
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    score.write('musicxml', fp=str(path))

    return path


def to_lilypond(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to LilyPond format (.ly).

    LilyPond is a music engraving program that produces
    high-quality sheet music. The .ly file can be compiled
    with LilyPond to generate PDF or PNG output.

    Args:
        score: The Score to export
        path: Destination file path (should end with .ly)

    Returns:
        Path to the written LilyPond file

    Example:
        >>> to_lilypond(my_score, 'output.ly')
        >>> # Then compile with: lilypond output.ly
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    # Generate LilyPond content manually
    ly_content = _generate_lilypond_content(score)
    path.write_text(ly_content, encoding='utf-8')

    return path


def _generate_lilypond_content(score: stream.Score) -> str:
    """Generate LilyPond format content from a score."""
    from music21 import pitch as m21pitch

    parts_ly = []

    for i, part in enumerate(score.parts):
        notes_ly = []
        for element in part.flatten().notesAndRests:
            if element.isNote:
                # Convert pitch to LilyPond notation
                p = element.pitch
                note_name = p.step.lower()

                # Handle accidentals
                if p.accidental:
                    if p.accidental.name == 'sharp':
                        note_name += 'is'
                    elif p.accidental.name == 'flat':
                        note_name += 'es'

                # Handle octave (middle C = c')
                octave = p.octave - 3
                if octave > 0:
                    note_name += "'" * octave
                elif octave < 0:
                    note_name += "," * abs(octave)

                # Handle duration
                duration = int(4 / element.quarterLength) if element.quarterLength > 0 else 4
                notes_ly.append(f"{note_name}{duration}")
            elif element.isRest:
                duration = int(4 / element.quarterLength) if element.quarterLength > 0 else 4
                notes_ly.append(f"r{duration}")

        part_content = " ".join(notes_ly)
        parts_ly.append(f'  \\new Staff {{\n    {part_content}\n  }}')

    parts_section = '\n'.join(parts_ly)

    lily_template = f'''\\version "2.20.0"
\\header {{
  title = "Canon"
  composer = "Generated by Cancrizans"
}}

\\score {{
  <<
{parts_section}
  >>
  \\layout {{ }}
  \\midi {{ }}
}}
'''

    return lily_template


def to_abc(score: stream.Score, path: Union[str, Path]) -> Path:
    """
    Export a score to ABC notation format (.abc).

    ABC notation is a text-based music notation system
    that's compact and easy to read/edit. It's widely used
    for folk music and can be rendered by many programs.

    Args:
        score: The Score to export
        path: Destination file path (should end with .abc)

    Returns:
        Path to the written ABC file

    Example:
        >>> to_abc(my_score, 'output.abc')
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    # Generate ABC content manually
    abc_content = _generate_abc_content(score)
    path.write_text(abc_content, encoding='utf-8')

    return path


def _generate_abc_content(score: stream.Score) -> str:
    """Generate ABC notation format content from a score."""
    # ABC header
    abc_lines = [
        "X:1",
        "T:Canon",
        "C:Generated by Cancrizans",
        "M:4/4",
        "L:1/4",
        "K:C",
        ""
    ]

    # Convert each part
    for i, part in enumerate(score.parts):
        if i > 0:
            abc_lines.append(f"V:{i+1}")

        notes_abc = []
        for element in part.flatten().notesAndRests:
            if element.isNote:
                # Convert pitch to ABC notation
                p = element.pitch
                note_name = p.step

                # Handle accidentals
                if p.accidental:
                    if p.accidental.name == 'sharp':
                        note_name = '^' + note_name
                    elif p.accidental.name == 'flat':
                        note_name = '_' + note_name

                # Handle octave (middle C = C)
                if p.octave >= 5:
                    note_name = note_name.lower()
                    if p.octave > 5:
                        note_name += "'" * (p.octave - 5)
                elif p.octave < 4:
                    note_name += "," * (4 - p.octave)

                # Handle duration (ABC uses different notation)
                duration = ""
                if element.quarterLength == 0.5:
                    duration = "/2"
                elif element.quarterLength == 2.0:
                    duration = "2"
                elif element.quarterLength == 1.5:
                    duration = "3/2"
                elif element.quarterLength != 1.0:
                    # General case
                    duration = str(int(element.quarterLength)) if element.quarterLength.is_integer() else f"{int(element.quarterLength*2)}/2"

                notes_abc.append(note_name + duration)
            elif element.isRest:
                duration = ""
                if element.quarterLength == 0.5:
                    duration = "/2"
                elif element.quarterLength == 2.0:
                    duration = "2"
                elif element.quarterLength != 1.0:
                    duration = str(int(element.quarterLength)) if element.quarterLength.is_integer() else f"{int(element.quarterLength*2)}/2"
                notes_abc.append("z" + duration)

        abc_lines.append(" ".join(notes_abc))

    return "\n".join(abc_lines)


def to_wav_via_sf2(
    midi_path: Union[str, Path],
    sf2_path: Union[str, Path],
    wav_path: Union[str, Path]
) -> Optional[Path]:
    """
    Convert MIDI to WAV using a SoundFont file.

    This function requires either FluidSynth or the midi2audio library.
    If neither is available, it returns None and prints a message.

    Args:
        midi_path: Path to input MIDI file
        sf2_path: Path to SoundFont (.sf2) file
        wav_path: Path for output WAV file

    Returns:
        Path to the WAV file if successful, None otherwise
    """
    midi_path = Path(midi_path)
    sf2_path = Path(sf2_path)
    wav_path = Path(wav_path)

    if not midi_path.exists():
        raise FileNotFoundError(f"MIDI file not found: {midi_path}")

    if not sf2_path.exists():
        raise FileNotFoundError(f"SoundFont file not found: {sf2_path}")

    wav_path.parent.mkdir(parents=True, exist_ok=True)

    try:
        # Try using midi2audio if available
        from midi2audio import FluidSynth

        fs = FluidSynth(sound_font=str(sf2_path))
        fs.midi_to_audio(str(midi_path), str(wav_path))

        return wav_path

    except ImportError:
        print(
            "WAV export requires midi2audio and FluidSynth.\n"
            "Install with: pip install midi2audio\n"
            "And ensure FluidSynth is installed on your system:\n"
            "  Ubuntu/Debian: sudo apt-get install fluidsynth\n"
            "  macOS: brew install fluid-synth\n"
            "  Windows: Download from https://www.fluidsynth.org/"
        )
        return None
    except Exception as e:
        print(f"Error converting MIDI to WAV: {e}")
        return None


def load_score(path: Union[str, Path]) -> stream.Score:
    """
    Load a score from a MusicXML or MIDI file.

    Args:
        path: Path to the file to load

    Returns:
        The loaded Score object
    """
    path = Path(path)

    if not path.exists():
        raise FileNotFoundError(f"File not found: {path}")

    score = m21.converter.parse(str(path))

    # Ensure we have a Score object
    if isinstance(score, stream.Score):
        return score
    elif isinstance(score, stream.Part):
        # Wrap single part in a score
        s = stream.Score()
        s.insert(0, score)
        return s
    else:
        # Try to convert other types
        s = stream.Score()
        s.insert(0, score)
        return s


def export_all(
    score: stream.Score,
    base_path: Union[str, Path],
    formats: Optional[list] = None
) -> dict:
    """
    Export a score to multiple formats at once.

    Args:
        score: The Score to export
        base_path: Base path (without extension) for output files
        formats: List of formats to export. Available: 'midi', 'musicxml',
                'lilypond', 'abc'. Defaults to all formats.

    Returns:
        Dictionary mapping format names to output file paths

    Example:
        >>> paths = export_all(my_score, 'output/canon')
        >>> # Creates: canon.mid, canon.musicxml, canon.ly, canon.abc
    """
    if formats is None:
        formats = ['midi', 'musicxml', 'lilypond', 'abc']

    base_path = Path(base_path)
    results = {}

    format_map = {
        'midi': ('.mid', to_midi),
        'musicxml': ('.musicxml', to_musicxml),
        'lilypond': ('.ly', to_lilypond),
        'abc': ('.abc', to_abc),
    }

    for fmt in formats:
        if fmt not in format_map:
            raise ValueError(f"Unknown format: {fmt}. Available: {list(format_map.keys())}")

        ext, export_func = format_map[fmt]
        output_path = base_path.parent / f"{base_path.name}{ext}"
        results[fmt] = export_func(score, output_path)

    return results


def set_metadata(
    score: stream.Score,
    title: Optional[str] = None,
    composer: Optional[str] = None,
    copyright: Optional[str] = None,
    date: Optional[str] = None,
    **kwargs
) -> stream.Score:
    """
    Set metadata fields on a score.

    Args:
        score: The Score to modify (modified in-place)
        title: Title of the piece
        composer: Composer name
        copyright: Copyright notice
        date: Date/year of composition
        **kwargs: Additional metadata fields (e.g., lyricist, dedication)

    Returns:
        The modified Score (for method chaining)

    Example:
        >>> set_metadata(score, title="My Canon", composer="J.S. Bach")
    """
    if not hasattr(score, 'metadata') or score.metadata is None:
        score.metadata = m21.metadata.Metadata()

    if title:
        score.metadata.title = title
    if composer:
        score.metadata.composer = composer
    if copyright:
        score.metadata.copyright = copyright
    if date:
        score.metadata.date = date

    # Handle additional fields
    for key, value in kwargs.items():
        setattr(score.metadata, key, value)

    return score


def get_metadata(score: stream.Score) -> dict:
    """
    Extract metadata from a score.

    Args:
        score: The Score to read metadata from

    Returns:
        Dictionary of metadata fields

    Example:
        >>> meta = get_metadata(score)
        >>> print(meta['title'], meta['composer'])
    """
    if not hasattr(score, 'metadata') or score.metadata is None:
        return {}

    metadata = {}

    # Standard fields
    standard_fields = ['title', 'composer', 'copyright', 'date',
                      'lyricist', 'dedication', 'movementName']

    for field in standard_fields:
        value = getattr(score.metadata, field, None)
        if value:
            metadata[field] = value

    return metadata


def merge_scores(*scores: stream.Score) -> stream.Score:
    """
    Merge multiple scores into a single score by combining their parts.

    All parts from all scores are added to a new score. Useful for
    combining separately-created voices or movements.

    Args:
        *scores: Variable number of Score objects to merge

    Returns:
        New Score containing all parts from input scores

    Example:
        >>> merged = merge_scores(score1, score2, score3)
    """
    if not scores:
        return stream.Score()

    merged = stream.Score()

    # Copy metadata from first score if available
    if hasattr(scores[0], 'metadata') and scores[0].metadata:
        merged.metadata = scores[0].metadata

    # Add all parts from all scores
    for score in scores:
        for part in score.parts:
            merged.insert(0, part)

    return merged


def extract_parts(
    score: stream.Score,
    indices: Union[int, list]
) -> stream.Score:
    """
    Extract specific parts/voices from a score.

    Args:
        score: The Score to extract from
        indices: Single index or list of indices to extract (0-based)

    Returns:
        New Score containing only the specified parts

    Example:
        >>> voice1_only = extract_parts(score, 0)
        >>> soprano_alto = extract_parts(score, [0, 1])
    """
    if isinstance(indices, int):
        indices = [indices]

    extracted = stream.Score()

    # Copy metadata if available
    if hasattr(score, 'metadata') and score.metadata:
        extracted.metadata = score.metadata

    parts = list(score.parts)

    for idx in indices:
        if idx < 0 or idx >= len(parts):
            raise IndexError(f"Part index {idx} out of range (0-{len(parts)-1})")
        extracted.insert(0, parts[idx])

    return extracted


def validate_import(path: Union[str, Path]) -> dict:
    """
    Validate an imported music file and return diagnostic information.

    Args:
        path: Path to the file to validate

    Returns:
        Dictionary with validation results:
        - 'valid': bool - whether file loaded successfully
        - 'format': str - detected format (midi, musicxml, etc.)
        - 'parts': int - number of parts/voices
        - 'measures': int - number of measures
        - 'duration': float - total duration in quarter notes
        - 'errors': list - any errors encountered

    Example:
        >>> info = validate_import('canon.mid')
        >>> if info['valid']:
        >>>     print(f"Loaded {info['parts']} parts")
    """
    path = Path(path)
    result = {
        'valid': False,
        'format': None,
        'parts': 0,
        'measures': 0,
        'duration': 0.0,
        'errors': []
    }

    if not path.exists():
        result['errors'].append(f"File not found: {path}")
        return result

    # Detect format from extension
    ext = path.suffix.lower()
    format_map = {
        '.mid': 'midi',
        '.midi': 'midi',
        '.xml': 'musicxml',
        '.musicxml': 'musicxml',
        '.mxl': 'musicxml',
        '.ly': 'lilypond',
        '.abc': 'abc'
    }
    result['format'] = format_map.get(ext, 'unknown')

    try:
        score = load_score(path)
        result['valid'] = True
        result['parts'] = len(score.parts)

        # Get duration
        if score.parts:
            result['duration'] = max(p.duration.quarterLength for p in score.parts)

        # Count measures (approximate)
        if score.parts:
            measures = score.parts[0].getElementsByClass(m21.stream.Measure)
            result['measures'] = len(measures)

    except Exception as e:
        result['errors'].append(str(e))

    return result


def convert_format(
    input_path: Union[str, Path],
    output_path: Union[str, Path]
) -> Path:
    """
    Convert a music file from one format to another.

    Format is auto-detected from file extensions.

    Args:
        input_path: Path to input file
        output_path: Path to output file (extension determines format)

    Returns:
        Path to the output file

    Example:
        >>> convert_format('canon.mid', 'canon.musicxml')
        >>> convert_format('score.xml', 'score.ly')
    """
    # Load the input file
    score = load_score(input_path)

    # Determine output format from extension
    output_path = Path(output_path)
    ext = output_path.suffix.lower()

    if ext in ['.mid', '.midi']:
        return to_midi(score, output_path)
    elif ext in ['.xml', '.musicxml', '.mxl']:
        return to_musicxml(score, output_path)
    elif ext == '.ly':
        return to_lilypond(score, output_path)
    elif ext == '.abc':
        return to_abc(score, output_path)
    else:
        raise ValueError(f"Unsupported output format: {ext}")
