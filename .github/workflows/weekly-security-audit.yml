name: Weekly Security Audit

on:
  schedule:
    # Every Saturday at 4:00 UTC
    - cron: '0 4 * * 6'
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'pyproject.toml'
      - 'requirements*.txt'

permissions:
  contents: read
  security-events: write
  issues: write

jobs:
  comprehensive-security-audit:
    name: Comprehensive Security Audit
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install security tools
        run: |
          python -m pip install --upgrade pip
          pip install pip-audit bandit[toml] safety-db semgrep
          pip install -e ".[dev]"

      - name: Dependency vulnerability scan
        id: pip-audit-scan
        continue-on-error: true
        run: |
          echo "### üîç Dependency Vulnerability Scan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if pip-audit --format json --output pip-audit-full.json; then
            echo "‚úÖ **No vulnerabilities found in dependencies**" >> $GITHUB_STEP_SUMMARY
            echo "vuln_count=0" >> $GITHUB_OUTPUT
          else
            # Count vulnerabilities
            VULN_COUNT=$(python -c "import json; data=json.load(open('pip-audit-full.json')); print(sum(len(d.get('vulns', [])) for d in data.get('dependencies', [])))" || echo "0")
            echo "vuln_count=$VULN_COUNT" >> $GITHUB_OUTPUT

            echo "‚ùå **$VULN_COUNT vulnerabilities found**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>View Details</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            pip-audit 2>&1 | head -50 >> $GITHUB_STEP_SUMMARY || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Static code security analysis (Bandit)
        id: bandit-scan
        continue-on-error: true
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üõ°Ô∏è Static Code Security Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if bandit -r cancrizans -f json -o bandit-full.json; then
            echo "‚úÖ **No security issues detected by Bandit**" >> $GITHUB_STEP_SUMMARY
            echo "bandit_issues=0" >> $GITHUB_OUTPUT
          else
            # Count issues by severity
            python << 'EOF' >> $GITHUB_STEP_SUMMARY
          import json
          from pathlib import Path

          data = json.loads(Path('bandit-full.json').read_text())
          results = data.get('results', [])

          high = sum(1 for r in results if r.get('issue_severity') == 'HIGH')
          medium = sum(1 for r in results if r.get('issue_severity') == 'MEDIUM')
          low = sum(1 for r in results if r.get('issue_severity') == 'LOW')

          print(f"**Security Issues Found:**")
          print(f"- üî¥ High: {high}")
          print(f"- üü° Medium: {medium}")
          print(f"- üü¢ Low: {low}")
          print()

          if high > 0:
              print("**High Severity Issues:**\n")
              for issue in results[:5]:
                  if issue.get('issue_severity') == 'HIGH':
                      print(f"- `{issue['filename']}:{issue['line_number']}` - {issue['issue_text']}")
          EOF

            echo "bandit_issues=$(python -c 'import json; print(len(json.load(open(\"bandit-full.json\")).get(\"results\", [])))')" >> $GITHUB_OUTPUT
          fi

      - name: Semgrep security scan
        id: semgrep-scan
        continue-on-error: true
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîé Semgrep Security Patterns" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Run semgrep with security rules
          semgrep --config=auto --json --output=semgrep-results.json cancrizans/ || true

          python << 'EOF' >> $GITHUB_STEP_SUMMARY
          import json
          from pathlib import Path

          if Path('semgrep-results.json').exists():
              data = json.loads(Path('semgrep-results.json').read_text())
              results = data.get('results', [])

              if not results:
                  print("‚úÖ **No security patterns detected**")
              else:
                  print(f"‚ö†Ô∏è **{len(results)} potential security issues found**\n")

                  # Group by severity
                  by_severity = {}
                  for result in results:
                      severity = result.get('extra', {}).get('severity', 'INFO')
                      if severity not in by_severity:
                          by_severity[severity] = []
                      by_severity[severity].append(result)

                  for severity in ['ERROR', 'WARNING', 'INFO']:
                      if severity in by_severity:
                          print(f"**{severity}:** {len(by_severity[severity])} issues")
          else:
              print("‚ö†Ô∏è Semgrep results not available")
          EOF

      - name: License compliance check
        id: license-check
        continue-on-error: true
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìú License Compliance" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          pip install pip-licenses

          # Generate license report
          pip-licenses --format=json --output-file=licenses.json

          python << 'EOF' >> $GITHUB_STEP_SUMMARY
          import json
          from pathlib import Path

          data = json.loads(Path('licenses.json').read_text())

          # Problematic licenses (copyleft, proprietary)
          problematic = ['GPL', 'AGPL', 'Commercial', 'Proprietary']

          licenses = {}
          issues = []

          for pkg in data:
              lic = pkg.get('License', 'UNKNOWN')
              licenses[lic] = licenses.get(lic, 0) + 1

              # Check for problematic licenses
              for prob in problematic:
                  if prob in lic:
                      issues.append((pkg['Name'], lic))

          print("**License Distribution:**\n")
          for lic, count in sorted(licenses.items(), key=lambda x: x[1], reverse=True)[:10]:
              print(f"- {lic}: {count} packages")

          if issues:
              print("\n‚ö†Ô∏è **Potentially Problematic Licenses:**\n")
              for name, lic in issues[:5]:
                  print(f"- `{name}`: {lic}")
          else:
              print("\n‚úÖ **No license compliance issues detected**")
          EOF

      - name: Secret scanning
        id: secret-scan
        continue-on-error: true
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîê Secret Scanning" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Use TruffleHog or simple grep patterns
          pip install truffleHog3

          if trufflehog3 --format json --output secrets.json . 2>&1; then
            if [ -f secrets.json ] && [ -s secrets.json ]; then
              echo "‚ö†Ô∏è **Potential secrets detected**" >> $GITHUB_STEP_SUMMARY
              echo "::warning::Potential secrets found in repository"
            else
              echo "‚úÖ **No secrets detected**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            # Fallback to basic pattern matching
            echo "Running basic secret pattern detection..." >> $GITHUB_STEP_SUMMARY

            # Check for common secret patterns
            if grep -r -E "(password|passwd|pwd|secret|token|api[_-]?key|private[_-]?key)\s*=\s*['\"][^'\"]{8,}" --include="*.py" --exclude-dir=".git" . > /dev/null 2>&1; then
              echo "‚ö†Ô∏è **Potential hardcoded secrets found** - manual review required" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ **No obvious secrets detected**" >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Supply chain security check
        continue-on-error: true
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚õìÔ∏è Supply Chain Security" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          python << 'EOF' >> $GITHUB_STEP_SUMMARY
          import subprocess
          import json

          # Check for packages without version pinning
          with open('pyproject.toml', 'r') as f:
              content = f.read()

          unpinned = []
          for line in content.split('\n'):
              if '"' in line and '>=' in line:
                  # Has lower bound but check if upper bound exists
                  if '<' not in line and '==' not in line:
                      pkg = line.split('"')[1].split('>')[0].strip()
                      unpinned.append(pkg)

          if unpinned:
              print(f"‚ö†Ô∏è **{len(unpinned)} dependencies without upper version bounds:**\n")
              for pkg in unpinned[:10]:
                  print(f"- `{pkg}`")
              print("\nConsider adding upper bounds for reproducible builds.")
          else:
              print("‚úÖ **All dependencies have version constraints**")
          EOF

      - name: Generate security score
        id: security-score
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Security Score" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          python << 'EOF' >> $GITHUB_STEP_SUMMARY
          # Calculate security score based on findings
          score = 100

          # Deduct points for vulnerabilities
          vuln_count = int("${{ steps.pip-audit-scan.outputs.vuln_count || 0 }}")
          score -= min(vuln_count * 5, 30)  # Max -30 for vulnerabilities

          # Deduct for code issues
          bandit_issues = int("${{ steps.bandit-scan.outputs.bandit_issues || 0 }}")
          score -= min(bandit_issues * 2, 20)  # Max -20 for bandit issues

          # Ensure score doesn't go below 0
          score = max(score, 0)

          # Determine grade
          if score >= 90:
              grade = "A"
              emoji = "üåü"
          elif score >= 80:
              grade = "B"
              emoji = "‚úÖ"
          elif score >= 70:
              grade = "C"
              emoji = "‚ö†Ô∏è"
          elif score >= 60:
              grade = "D"
              emoji = "‚ö†Ô∏è"
          else:
              grade = "F"
              emoji = "‚ùå"

          print(f"### {emoji} Overall Score: {score}/100 (Grade: {grade})")
          print()

          if score >= 90:
              print("**Excellent!** Your security posture is strong.")
          elif score >= 70:
              print("**Good**, but there's room for improvement.")
          else:
              print("**Needs attention** - review the findings above.")
          EOF

      - name: Upload security reports
        uses: actions/upload-artifact@v4
        with:
          name: security-audit-${{ github.run_number }}
          path: |
            pip-audit-full.json
            bandit-full.json
            semgrep-results.json
            licenses.json
            secrets.json
          retention-days: 90

      - name: Create security issue if critical
        if: steps.pip-audit-scan.outputs.vuln_count > 0 || steps.bandit-scan.outputs.bandit_issues > 5
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const vulnCount = '${{ steps.pip-audit-scan.outputs.vuln_count }}' || 0;
            const banditIssues = '${{ steps.bandit-scan.outputs.bandit_issues }}' || 0;

            // Check for existing security audit issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'security,automated'
            });

            const existingIssue = issues.data.find(i =>
              i.title.includes('Weekly Security Audit')
            );

            let body = '## üîí Weekly Security Audit Results\n\n';
            body += `**Run:** ${context.runNumber}\n`;
            body += `**Date:** ${new Date().toISOString().split('T')[0]}\n\n`;

            if (vulnCount > 0) {
              body += `### ‚ö†Ô∏è Vulnerabilities: ${vulnCount}\n\n`;
              body += 'Dependency vulnerabilities were detected. Review the workflow run for details.\n\n';
            }

            if (banditIssues > 5) {
              body += `### ‚ö†Ô∏è Code Security Issues: ${banditIssues}\n\n`;
              body += 'Security issues were detected in the code. Review the Bandit report.\n\n';
            }

            body += '---\n*This issue was automatically created by weekly-security-audit workflow*\n';

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'üîí Weekly Security Audit - Action Required',
                body: body,
                labels: ['security', 'automated', 'high-priority']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: body
              });
            }
